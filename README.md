# # 《函数实验报告》

## 一、实验名称
函数相关操作实验

## 二、实验目的
1. 熟练掌握定义函数的方法，能够根据具体需求合理设计函数结构。
2. 深入理解函数实参与形参的对应关系以及“值传递”的方式，明确参数传递过程中数据的变化规律。
3. 学会函数的嵌套调用和递归调用的方法，能够利用这些技术解决复杂的问题。
4. 清晰掌握全局变量、局部变量、动态变量和静态变量的概念和使用方法，根据程序逻辑正确选择变量类型。
5. 理解和掌握多模块的程序设计与调试的方法，提高程序的模块化程度和可维护性。

## 三、实验环境
- 操作系统：[具体操作系统名称及版本]
- 编程环境：[如 Visual Studio Code、Dev-C++等及版本]

## 四、实验内容及步骤

### （一）求字符串长度函数
1. **问题描述**
编写一个函数，使用指针来计算输入字符串的长度，并在 main 函数中进行输入和输出，且不能使用 strlen()函数。
2. **算法思路**
通过指针遍历字符串，直到遇到字符串结束标志'\0'，在此过程中使用一个计数器记录字符的个数，该计数器的值即为字符串的长度。
3. **代码实现**
```c
#include <stdio.h>

// 计算字符串长度的函数
int stringLength(char *str) {
    int len = 0;
    while (*str!= '\0') {
        len++;
        str++;
    }
    return len;
}

int main() {
    char str[100];
    printf("请输入字符串：");
    scanf("%s", str);

    int length = stringLength(str);
    printf("字符串的长度为：%d\n", length);

    return 0;
}
```
4. **运行结果及分析**
输入不同的字符串，如“hello”，程序输出“字符串的长度为：5”。分析可知，函数通过指针逐个字符地遍历字符串，正确地计算出了字符串的长度。在函数中，形参`str`接收了 main 函数中字符串的首地址，通过不断移动指针并计数，实现了长度的计算，体现了指针在处理字符串时的灵活性和高效性。

### （二）数组元素反序函数
1. **问题描述**
在主函数中输入 10 个数，编写函数`invert()`将这 10 个数按反序存放，并在主函数中输出排好序的数。
2. **算法思路**
使用两个指针，一个指向数组的头部，一个指向数组的尾部，通过交换两个指针所指向的元素，逐步将数组元素反序。
3. **代码实现**
```c
#include <stdio.h>

// 数组反序函数
void invert(int *arr, int n) {
    int *start = arr;
    int *end = arr + n - 1;
    while (start < end) {
        int temp = *start;
        *start = *end;
        *end = temp;
        start++;
        end--;
    }
}

int main() {
    int arr[10];
    printf("请输入 10 个数：");
    for (int i = 0; i < 10; i++) {
        scanf("%d", &arr[i]);
    }

    invert(arr, 10);

    printf("反序后的数组为：");
    for (int i = 0; i < 10; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");

    return 0;
}
```
4. **运行结果及分析**
输入一组数，如 1 2 3 4 5 6 7 8 9 10，程序输出“反序后的数组为：10 9 8 7 6 5 4 3 2 1”。分析可得，`invert`函数通过双指针法有效地实现了数组元素的反序。在函数调用时，将数组名作为实参传递给形参`arr`，由于数组名代表数组的首地址，在函数中对形参数组的操作实际上是对实参数组的操作，实现了数组元素的原地反序，这种传递方式体现了数组作为函数参数时的“值传递”特点，即传递的是数组的首地址。

### （三）多功能计算函数
1. **问题描述**
在主函数中输入 2 个数`a`、`b`，编写函数`add()`、`sub()`、`mul()`分别计算两个数的和、差、积，并编写函数`process()`分别调用上述函数来实现相应的计算，并在主函数中输出结果。
2. **算法思路**
`add`函数将两个数相加并返回结果，`sub`函数用第一个数减去第二个数并返回差值，`mul`函数计算两个数的乘积并返回。`process`函数在内部依次调用`add`、`sub`、`mul`函数，并将结果传递回主函数进行输出。
3. **代码实现**
```c
#include <stdio.h>

// 加法函数
int add(int a, int b) {
    return a + b;
}

// 减法函数
int sub(int a, int b) {
    return a - b;
}

// 乘法函数
int mul(int a, int b) {
    return a * b;
}

// 处理函数
void process(int a, int b) {
    int sum = add(a, b);
    int diff = sub(a, b);
    int product = mul(a, b);

    printf("%d 和 %d 的和为：%d\n", a, b, sum);
    printf("%d 和 %d 的差为：%d\n", a, b, diff);
    printf("%d 和 %d 的积为：%d\n", a, b, product);
}

int main() {
    int a, b;
    printf("请输入两个数：");
    scanf("%d %d", &a, &b);

    process(a, b);

    return 0;
}
```
4. **运行结果及分析**
输入两个数，如 5 和 3，程序输出“5 和 3 的和为：8”“5 和 3 的差为：2”“5 和 3 的积为：15”。分析可知，通过函数的嵌套调用，`process`函数有效地整合了`add`、`sub`、`mul`函数的功能，实现了对两个数的多种运算。在函数调用过程中，实参`a`、`b`的值分别传递给各个函数的形参，函数根据形参进行计算并返回结果，体现了函数之间的协作和参数传递的作用，使得程序结构清晰，易于维护和扩展。

## 五、实验总结
通过本次实验，我在函数相关知识和技能方面取得了显著的进步。

在函数定义方面，我能够根据不同的任务需求准确地设计函数的参数和返回值，如在字符串长度计算函数中，合理地使用指针作为参数来处理字符串；在数组反序函数中，通过传递数组名和数组长度，实现了对数组的有效操作。

对于函数实参与形参的“值传递”方式有了更深入的理解。在数组反序和多功能计算等函数中，清晰地看到了值传递过程中数据的单向传递特点，以及如何利用这种传递方式在函数中对数据进行处理而不影响原始数据的副本，同时也明白了在需要修改原始数据时，通过传递指针或数组名等方式可以实现对原始数据的间接操作。

函数的嵌套调用和递归调用方法的学习使我能够解决更复杂的问题。在多功能计算函数中，成功地运用了嵌套调用，将多个简单功能的函数组合成一个更复杂的功能模块，提高了程序的模块化程度。虽然本次实验未涉及递归调用，但通过复习和实践，对其原理和应用场景有了进一步的认识，为今后解决需要递归思想的问题奠定了基础。

在变量类型方面，我对全局变量、局部变量、动态变量和静态变量的概念和使用场景有了更明确的区分。在实际编程中，能够根据变量的作用域和生命周期需求，正确地选择变量类型，避免了因变量使用不当而导致的程序错误。

在多模块程序设计与调试方面，本次实验虽然没有涉及多个源文件的复杂情况，但通过将不同功能的函数进行合理组织，初步体会到了模块化设计的优势，即提高了程序的可读性、可维护性和可扩展性。在调试过程中，学会了利用调试工具逐步跟踪函数的执行过程，查找和解决函数参数传递、逻辑错误等问题，进一步提高了自己的编程能力和问题解决能力。

然而，在实验过程中也遇到了一些问题。例如，在字符串长度计算函数中，最初忘记了指针移动的操作，导致程序陷入死循环；在数组反序函数中，对双指针的边界条件判断出现错误，导致部分元素未正确反序。通过这些问题的解决，我更加深刻地认识到编程时需要严谨细致，对每一个细节都要进行充分的思考和验证。

总之，本次实验是一次非常有意义的实践活动，不仅巩固了函数的相关知识，还培养了我的编程思维和解决实际问题的能力，为今后的编程学习和实践积累了宝贵的经验。 
